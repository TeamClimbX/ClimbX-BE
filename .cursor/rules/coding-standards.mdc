---
description: "Coding standards and conventions for the project."
---
# Coding Standards and Conventions

## Java 코딩 컨벤션

### 1. 네이밍 규칙

#### 클래스명
- PascalCase 사용
- 역할을 명확히 나타내는 이름
```java
// Good
public class UserAccountEntity { }
public class AuthController { }
public class JwtAuthenticationFilter { }

// Bad
public class User { }  // 너무 일반적
public class AuthCtrl { }  // 축약형 지양
```

#### 메서드명
- camelCase 사용
- 동사로 시작
- 의도를 명확히 표현
```java
// Good
public void createUser() { }
public boolean isValidUser() { }
public List<User> findActiveUsers() { }

// Bad
public void user() { }  // 동사 없음
public void create() { }  // 대상 불명확
```

#### 변수명
- camelCase 사용
- 의미있는 이름 사용
```java
// Good
private String userName;
private List<UserEntity> activeUsers;
private LocalDateTime createdAt;

// Bad
private String n;  // 의미 불명확
private List<UserEntity> list;  // 일반적 이름
```

#### 상수명
- UPPER_SNAKE_CASE 사용
```java
// Good
public static final String DEFAULT_USER_ROLE = "USER";
public static final int MAX_LOGIN_ATTEMPTS = 3;
```

### 2. 어노테이션 사용 규칙

#### 클래스 레벨 어노테이션 순서
```java
@Entity
@Table(name = "users")
@NoArgsConstructor(access = lombok.AccessLevel.PROTECTED)
@AllArgsConstructor(access = lombok.AccessLevel.PRIVATE)
@Getter
@Accessors(fluent = true)
@Builder
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class UserEntity extends BaseTimeEntity {
    // 구현
}
```

#### 메서드 레벨 어노테이션
```java
@Transactional
@Override
public UserResponseDto createUser(UserCreateRequestDto request) {
    // 구현
}
```

#### 필드 레벨 어노테이션
```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;

@Column(nullable = false, unique = true)
@Size(min = 2, max = 50)
private String username;
```

### 3. 패키지 구조 규칙

#### 기본 패키지 구조
```
com.climbx.climbx.{domain}
├── {Domain}Controller.java
├── {Domain}Service.java
├── dto/
│   ├── {Domain}CreateRequestDto.java
│   ├── {Domain}UpdateRequestDto.java
│   └── {Domain}ResponseDto.java
├── entity/
│   └── {Domain}Entity.java
├── repository/
│   └── {Domain}Repository.java
└── exception/
    ├── {Domain}NotFoundException.java
    └── {Domain}ValidationException.java
```

## Spring Boot 특화 규칙

### 1. Controller 작성 규칙

#### 기본 구조
```java
@RestController
@RequestMapping("/api/{domain}")
@RequiredArgsConstructor
@Tag(name = "Domain", description = "도메인 API")
public class DomainController {
    
    private final DomainService domainService;
    
    @PostMapping
    @Operation(summary = "생성", description = "새로운 항목을 생성합니다.")
    public ApiResponse<DomainResponseDto> create(
            @Valid @RequestBody DomainCreateRequestDto request) {
        
        DomainResponseDto response = domainService.create(request);
        return ApiResponse.success(response);
    }
}
```

#### URL 설계 규칙
- RESTful 설계 원칙 준수
- 명사 사용, 동사 지양
- 계층 구조 표현
```java
// Good
GET /api/users/{userId}
POST /api/users
PUT /api/users/{userId}
DELETE /api/users/{userId}
GET /api/users/{userId}/reviews

// Bad
GET /api/getUser/{userId}
POST /api/createUser
GET /api/user-reviews/{userId}
```

### 2. Service 작성 규칙

#### 기본 구조
```java
@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class DomainService {
    
    private final DomainRepository domainRepository;
    
    @Transactional
    public DomainResponseDto create(DomainCreateRequestDto request) {
        // 비즈니스 로직 구현
        DomainEntity entity = DomainEntity.builder()
                .field1(request.field1())
                .field2(request.field2())
                .build();
        
        DomainEntity savedEntity = domainRepository.save(entity);
        return DomainResponseDto.from(savedEntity);
    }
    
    public DomainResponseDto findById(Long id) {
        DomainEntity entity = domainRepository.findById(id)
                .orElseThrow(() -> new DomainNotFoundException(id));
        
        return DomainResponseDto.from(entity);
    }
    
    // 내부 메서드는 protected 또는 private 사용
    protected DomainEntity findEntityById(Long id) {
        return domainRepository.findById(id)
                .orElseThrow(() -> new DomainNotFoundException(id));
    }
}
```

#### 트랜잭션 규칙
- 클래스 레벨: `@Transactional(readOnly = true)`
- 쓰기 메서드: `@Transactional` (메서드 레벨)
- 읽기 메서드: 어노테이션 생략 (클래스 설정 상속)

### 3. Entity 작성 규칙

#### 기본 구조
```java
@Entity
@Table(name = "table_name")
@SQLRestriction("deleted_at IS NULL")
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Getter
@Accessors(fluent = true)
@Builder
public class DomainEntity extends BaseTimeEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    @NotBlank
    @Size(max = 100)
    private String requiredField;
    
    @Column
    @Size(max = 200)
    private String optionalField;
    
    // 비즈니스 메서드
    public void updateField(String newValue) {
        this.requiredField = newValue;
    }
}
```

#### Entity 작성 주의사항
- `@NoArgsConstructor(access = AccessLevel.PROTECTED)` 필수
- `@AllArgsConstructor(access = AccessLevel.PRIVATE)` 추가
- `@Accessors(fluent = true)` 사용으로 fluent 접근자 제공
- `@SQLRestriction("deleted_at IS NULL")` 추가 (soft delete 사용 시)
- `@Setter` 사용 금지 (불변성 보장)
- Builder 패턴 사용 권장
- 비즈니스 로직 메서드 추가 권장
- Bean Validation 어노테이션 적극 활용

### 4. DTO 작성 규칙

#### Request DTO (Record 패턴)
```java
public record DomainCreateRequestDto(
    @NotBlank(message = "필수 필드는 비어있을 수 없습니다.")
    @Size(max = 100, message = "최대 100자까지 입력 가능합니다.")
    String requiredField,
    
    @Size(max = 200, message = "최대 200자까지 입력 가능합니다.")
    String optionalField,
    
    @NotNull(message = "숫자 필드는 필수입니다.")
    @Min(value = 1, message = "1 이상이어야 합니다.")
    @Max(value = 100, message = "100 이하여야 합니다.")
    Integer numberField
) {
}
    
#### Response DTO (Record 패턴)
```java
@Builder
public record DomainResponseDto(
    Long id,
    String requiredField,
    String optionalField,
    LocalDateTime createdAt,
    LocalDateTime updatedAt
) {
    public static DomainResponseDto from(DomainEntity entity) {
        return DomainResponseDto.builder()
                .id(entity.id())
                .requiredField(entity.requiredField())
                .optionalField(entity.optionalField())
                .createdAt(entity.createdAt())
                .updatedAt(entity.updatedAt())
                .build();
    }
}
    }
}
```

## 예외 처리 규칙

### 1. Custom Exception 구조
```java
// 도메인별 예외 클래스
public class DomainNotFoundException extends BusinessException {
    public DomainNotFoundException(Long domainId) {
        super(ErrorCode.DOMAIN_NOT_FOUND);
        addContext("domainId", domainId);
    }
    
    public DomainNotFoundException(String identifier) {
        super(ErrorCode.DOMAIN_NOT_FOUND);
        addContext("identifier", identifier);
    }
}

public class DomainValidationException extends BusinessException {
    public DomainValidationException(String field, String value) {
        super(ErrorCode.DOMAIN_VALIDATION_ERROR);
        addContext("field", field);
        addContext("value", value);
    }
}
```

### 2. ErrorCode 정의
```java
// ErrorCode enum에 추가 (도메인별 prefix 사용)
DOMAIN_NOT_FOUND(404, "D001", "항목을 찾을 수 없습니다."),
DOMAIN_VALIDATION_ERROR(400, "D002", "검증 오류가 발생했습니다."),
DOMAIN_DUPLICATE_ERROR(409, "D003", "중복된 항목입니다."),
DOMAIN_ACCESS_DENIED(403, "D004", "접근 권한이 없습니다."),
```

## 테스트 작성 규칙

### 1. 테스트 클래스 구조 (Nested 패턴)
```java
@ExtendWith(MockitoExtension.class)
@DisplayName("DomainService 테스트")
class DomainServiceTest {
    
    @Mock
    private DomainRepository domainRepository;
    
    @InjectMocks
    private DomainService domainService;
    
    @Nested
    @DisplayName("생성 테스트")
    class CreateTest {
        
        @Test
        @DisplayName("정상적으로 생성되어야 한다")
        void create_Success() {
            // given
            DomainCreateRequestDto request = new DomainCreateRequestDto(
                "test", "optional", 10
            );
            
            DomainEntity entity = DomainEntity.builder()
                    .requiredField("test")
                    .optionalField("optional")
                    .numberField(10)
                    .build();
            
            given(domainRepository.save(any(DomainEntity.class))).willReturn(entity);
            
            // when
            DomainResponseDto response = domainService.create(request);
            
            // then
            assertThat(response.requiredField()).isEqualTo("test");
            assertThat(response.optionalField()).isEqualTo("optional");
            
            then(domainRepository).should().save(any(DomainEntity.class));
        }
        
        @Test
        @DisplayName("중복 데이터 생성 시 예외가 발생한다")
        void create_DuplicateData_ThrowsException() {
            // given
            DomainCreateRequestDto request = new DomainCreateRequestDto("test", null, 10);
            
            given(domainRepository.existsByRequiredField("test")).willReturn(true);
            
            // when & then
            assertThatThrownBy(() -> domainService.create(request))
                .isInstanceOf(DomainDuplicateException.class);
            
            then(domainRepository).should(never()).save(any(DomainEntity.class));
        }
    }
    
    @Nested
    @DisplayName("조회 테스트")
    class FindTest {
        
        @Test
        @DisplayName("ID로 정상 조회가 되어야 한다")
        void findById_Success() {
            // given, when, then 패턴
        }
        
        @Test
        @DisplayName("존재하지 않는 ID 조회 시 예외가 발생한다")
        void findById_NotFound_ThrowsException() {
            // given, when, then 패턴
        }
````
